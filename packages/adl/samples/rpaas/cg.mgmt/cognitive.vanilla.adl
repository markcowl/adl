model ArmCreateRequest<T>
{
    @header if-none-match: string = '*';
    ... ArmRequest<T>;
}

model ArmUpdateRequest<T>
{
    // note: placeholder, how do we access the value from an input type?
    @header if-match: string = T.eTag;
    ... ArmRequest<T>
}

model AccountResource: ArmTrackedResource<AccountProperties>;

@ArmTrackedResource(AccountProperties, 'Microsoft.CognitiveServices/accounts')
interface Account {
  @doc("Create the account if it does not exist")
  @put create(@body request: ArmCreateRequest<AccountResource>)  : ArmResponse<AccountResource>;
  @doc("Update the account, if the server eTag matches the request eTag")
  @put update(@body request: ArmUpdateRequest<AccountResource>) : ArmResponse<AccountResource>;
  @post listKeys() : ArmResponse<AccountKeys>;
  @post generateKey(@body parameters: RegenerateKeyParameters) : ArmResponse<AccountKeys>;

  @rest('accountSkus')
  interface AccountSkus {
    @get
    listAvailableSkus() : Page<AccountSku>;
  }

  @rest('usages')
  interface AccountUsages{
    @get
    getUsages(@query filter: OdataFilter) : Page<AccountUsage>;
  }

  @ArmSubResource(PrivateEndpointConnectionProperties, 'privateEndpointConnections')
  interface PrivateEndpointConnections {}

  @rest('privateLinkResources')
  interface PrivateLinkResources {
      @get list() : Page<PrivateLinkResource>;
  }
}

@rest('/subscriptions/{subscriptionId}/providers/Microsoft.CognitiveServices')
interface AccountNameAvailability {
  @post
  checkDomainAvailability(@path subscriptionId: string, @body parameters: DomainAvailabilityParameters) : Response<DomainAvailabilityResult>;
}

@rest('/subscriptions/{subscriptionId}/locations/{location}/providers/Microsoft.CognitiveServices')
interface AccountSkuAvailability {
  @post
  checkSkuAvailability(@path subscriptionId: string, @path location: string, @body parameters: SkuAvailabilityParameters) : Response<SkuAvailabilityResult>;
}

@rest('/subscriptions/{subscriptionId}/providers/Microsoft.CognitiveServices/skus')
interface AccountSkuList {
  @get
  listSkus(@path subscriptionId: string) : Page<AccountSku>;
}

// Private endpoint resources


// TODO: appropriate pattern restrictions for specialized string values
@format("[a-z]\w+")
model DnsPart: string;

@format("[a-z]\w+\.[a-z]\w+\.[a-z]\w+")
model DnsName: string;

//TODO: This a strawman for ARM serialization of a logical MAP as a sequence of Key/Value pairs
model SequenceMap<T, U> : SequenceElement<T, U>[];
model SequenceElement<T, U> {
  name: T;
  value: U;
}

// TODO: Belongs in ADL-RPaaS, along with similar credential types
@secret
model KeyCredential : string;

//TODO: Belongs in ADL-RPaaS.  Reusable types for resource type references
@format("([a-z]\w+\/)+[a-z]\w+")
model ResourceType: string;

model NetworkRuleAction: "Allow" | "Deny" | string;
model NetworkRuleset {
  //TODO: Modeling non-restrictive enumerations
  @doc("The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after the bypass property has been evaluated.")
  defaultAction: NetworkRuleAction = "Deny";
            
  @doc("The list of IP address rules.")
  ipRules: IPRule[];

  @doc("The list of virtual network rules.")
  virtualNetworkRules: VirtualNetworkRule[];
}

model IPRule {
  @doc("description": "An IPv4 address range in CIDR notation, such as '124.56.78.91' (simple IP address) or '124.56.78.0/24' (all addresses that start with 124.56.78).")
  @format("[\d]{1,3}\.[\d]{1,3}\.[\d]{1,3}\.[\d]{1,3}\[/\d\d?\d?]?")
  value: string;
}

model VirtualNetworkRule {
  //TODO: define a restriction for ResourceReference that allows specifying type and other constraints
  @doc("Full resource id of a vnet subnet, such as '/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1'.")
  @required
  @format("/subscriptions/\w+/resourceGroups/\w+/providers/Microsoft.Network/virtualNetworks/\w+/subnets/\w+")
  id: string;
  
  @doc("Gets the state of the virtual network rule")
  state: string;
          
  @doc("Ignore missing vnet service endpoint or not.")
  ignoreMissingVnetServiceEndpoint: boolean;
}

// We should have a standard model for key reference, and it should just be Key Uri (which includes version)
model KeyVaultProperties {
  @doc("Name of the KeyVault")
  keyName: DnsPart;

  @doc("Version of the Key from KeyVault")
  keyVersion: string;

  @doc("Uri of the KeyVault")
  keyVaultUri: Uri;
}

model EncryptionKeySource: "Microsoft.CognitiveServices" | "Microsoft.KeyVault" | string;
model Encryption {
  @doc("Properties of KeyVault") 
  keyVaultProperties: KeyVaultProperties;

  @doc("Enumerates the possible value of keySource for Encryption")
  keySource: EncryptionKeySource;
}

// Again, a resource reference standard would be very useful, including type and potentially property constraints
model UserOwnedStorage {
  @doc("Resource id of a Microsoft.Storage account")
  @format("/subscriptions/\w+/resourceGroups/\w+/providers/Microsoft.Storage/accounts/\w+")
  resourceId: string;
}

// TODO: polymorphism / dependencies between properties
model AccountApiProperties {
  ... QnAMakerProperties;
  ... BingSearchProperties;
  ... PersonalizationPropeties;
  ... MetricsAdvisorProperties;
}

model QnAMakerProperties {
  @doc("(QnAMaker Only) The runtime endpoint of QnAMaker.")
  qnaRuntimeEndpoint: string;
}

model BingSearchProperties {
  @doc("(Bing Search Only) The flag to enable statistics of Bing Search.")
  statisticsEnabled: boolean;
} 

model PersonalizationProperties {
  @doc("(Personalization Only) The flag to enable statistics of Bing Search.")
  @secret
  @format("^( *)Endpoint=sb://(.*);( *)SharedAccessKeyName=(.*);( *)SharedAccessKey=(.*)$")
  @length(1000)
  eventHubConnectionString : string;
  
  @doc("(Personalization Only) The storage account connection string.")
  @secret
  @format("^(( *)DefaultEndpointsProtocol=(http|https)( *);( *))?AccountName=(.*)AccountKey=(.*)EndpointSuffix=(.*)$")
  @length(1000)
  storageAccountConnectionString: string;
}

model MetricsAdvisorProperties {
  // TODO GUID/uuid pattern
  @doc("(Metrics Advisor Only) The Azure AD Client Id (Application Id).")
  @length(500)
  aadClientId : string;
  
  @doc("(Metrics Advisor Only) The Azure AD Tenant Id.")
  @length(500)
  aadTenantId: string;
            
  @doc("(Metrics Advisor Only) The super user of Metrics Advisor.")
  @length(500)
  superUser: string;
  
  @doc("(Metrics Advisor Only) The website name of Metrics Advisor.")
  @length(500)
  websiteName: DnsPart;
}

model AccountProvisioningState: "Creating" | "ResolvingDNS" | "Moving" | 
              "Deleting" | "Succeeded" | "Failed";

@doc('Properties of a Cognitive Services Account')
model AccountProperties {
     // note: one possible modeling of a non-restrictive enum
     @visibility('read')
     @doc("Gets the status of the cognitive services account at the time the operation was called")
     provisioningState : AccountProvisioningState | string;
          
     @doc("Endpoint of the created account.")
     @visibility('read')
     endpoint: Uri;

     @doc("The internal identifier.")
     @visibility('read')
     internalId: string;

     // TODO: this is serialized as an array of name/value pairs, but is a logical dictionary
     // Should we have serialization-related bindings for this?
     @doc("Gets the capabilities of the cognitive services account. Each item indicates the capability of a specific feature. The values are read-only and for reference only.")
     @visibility('read')
     capabilities: SequenceMap<string, string>;

     @doc("Optional subdomain name used for token-based authentication.")
     customSubDomainName: DnsPart;

     @doc("A collection of rules governing the accessibility from specific network locations.")
     networkAcls: NetworkRuleset;

     @doc("The encryption properties for this resource.")
     encryption: Encryption;

     @doc("The storage accounts for this resource.")
     userOwnedStorage: UserOwnedStorage[];
           
     @doc("Whether or not public endpoint access is allowed for this account. Value is optional but if passed in, must be 'Enabled' or 'Disabled'")
     publicNetworkAccess: "Enabled" | "Disabled" | string;

     @doc("The api properties for special APIs.")      
     apiProperties: AccountApiProperties;

    // Priavte endpoint sdditions
    @doc("Private endpoint connections for this account.")
    privateEndpointConnections: PrivateEndpointCollection[];

     // This is somewhat annoying.  Should we simply standardize on creationDate and modificationDate 
     // and allow opt out if there is good reason?       
     @doc("Gets the date of cognitive services account creation.")
     dateCreated: DateTime;  
}

model PrivateEndpointConnection {
    ... ArmResource<PrivateEndpointConnectionProperties>;
}

model PrivateEndpointConnectionProperties {
    privateEndpoint: PrivateEndpoint;
    privateLinkServiceConnectionState: PrivateLinkServiceConnectionState | string;
    // resource reference for resource groupIds
    @format("/subscriptions/\w+/resourceGroups/\w+")
    groupIds: string[];
}

model PrivateEndpoint {
    // resource reference for private Endpoint
    @format("/subscriptions/\w+/resourceGroups/\w+/providers/Microsoft.Network/privateEndpoints/\w+")
    id: string;
}

model PrivateLinkServiceConnectionState : "Pending" | "Approved" | "Rejected" | "Disconnected";

model PrivateLinkResource : ArmResource<PrivateLinkResourceProperties>;

model PrivateLinkResourceProperties {
    groupId: string;
    displayName: string;
    requiredMembers: string[];
    requiredZoneName: string[];
}

model AccountKeys {
  @doc("Gets the value of key 1.")
  key1: KeyCredential;
            
  @doc("Gets the value of key 2.")
  key2: KeyCredential;
}

// follow this pattern to allow naming the enumeration
model AccountKeyName: "Key1" | "Key2";
model RegenerateKeyParameters {
  @doc("key name to generate (Key1|Key2)")
  keyName : AccountKeyName;
}

model DomainAvailabilityParameters {
  @doc("The subdomain name to use.")
  @required
  subdomainName: string;

  @doc("The type of the resource.")
  @required
  type: ResourceType;
}

model DomainAvailabilityResult {
  @doc("Indicates the given Domain is available or not.")
  isSubdomainAvailable: boolean;
            
  @doc("Reason why the Domain is not available.")
  reason: string;
  
  @doc("The subdomain name to use.")
  subdomainName: DnsPart;

  @doc("The type of the resource.")
  type: ResourceType;
}

model SkuAvailabilityParameters {
  // TODO: should have a link to the api to retrieve valid values
  @doc("The SKU of the resource.")
  @required
  skus: string[];

  @doc("The kind of the resource.")
  @required
  kind: string;

  @doc("The type of the resource.")
  @required
  type: ResourceType;
}

model SkuAvailabilityResult {
    @doc("The kind of the resource.")
    kind: string;

    @doc("The type of the resource.")
    type: string;
    
    //TODO: Should have a link to the API that lists valid values
    @doc("The Sku name of the resource.")
    skuName: string;
    
    @doc("Indicates the given SKU is available or not.")
    skuAvailable: boolean;
    
    @doc("Reason why the SKU is not available.")
    reason: string;
          
    @doc("Additional error message.")
    message: string;
}

@doc("Describes an available CognitiveServices Sku")
model AccountSku {
  @doc("The type of resource the SKU applies to.")
  @visibility('read')
  resourceType: ResourceType;

  @doc("The name of the Sku.")
  @visibility('read')
  name: string;

  @doc("Specifies the tier of Cognitive Services account.")
  @visibility('read')
  tier: string;

  @doc("The Kind of resources that are supported in this SKU.")
  @visibility('read')
  kind: string;

  @doc("The set of locations where the SKU is available.")
  @visibility('read')
  locations: Location[];

  @doc("The restrictions because of which SKU cannot be used. This is empty if there are no restrictions.")
  @visibility('read')
  restrictions: SkuRestriction[];
}

// enum types: use this pattern to allow client names
model RestrictionReason: "QuotaId" | "NotAvailableForSubscription";
model RestrictionType: "Location" | "Zone";

model SkuRestriction {
  @doc("The type of restriction.")
  @visibility('read')
  type: RestrictionType;

  @doc("The value of restrictions. If the restriction type is set to location. This would be different locations where the SKU is restricted.")
  @visibility('read')
  values: string[];

  @doc("The information about the restriction where the SKU cannot be used.")
  restrictionInfo: RestrictionInfo;

  @doc("The reason for the restriction.")
  @visibility('read')
  reasonCode: RestrictionReason | string;
}

model RestrictionInfo{
  @doc("Locations where the Sku is restricted.")
  @visibility('read')
  locations: Location[];

  @doc("AvailabilityZones where the Sku is restricted.")
  @visibility('read')
  zones: string[];
}

model UnitType: "Count" | "Bytes" | "Seconds" | "Percent" | "CountPerSecond" | "BytesPerSecond" | "Milliseconds";

model MetricName {
  @doc("The name of the metric.")
  @visibility('read')
  value: string;

  @doc("The friendly name of the metric.")
  @visibility('read')
  localizedValue: string;
}

model AccountQuotaStatus: "Included" | "Blocked" | "InOverage" | "Unknown";
model AccountUsage {
  @doc("The unit of the metric.")
  @visibility('read')
  // one possibility for marking an enumeration as open
  unit: UnitType | string;

  @doc("The name information for the metric.")
  @visibility('read')
  name: MetricName;

  @doc("The quota period used to summarize the usage values.")
  @visibility('read')
  quotaPeriod: interval;

  @doc("Maximum value for this metric.")
  @visibility('read')
  limit: double;

  @doc("Current value for this metric.")
  @visibility('read')
  currentValue: double;

  @doc("Next reset time for current quota.")
  @visibility('read')
  nextResetTime: DateTime;
  
  @doc("Cognitive Services account quota usage status.")
  @visibility('read')
  status: AccountQuotaStatus | string;
}

// placeholder - we should have some opinionated default for Odata filters
model OdataFilter: string;